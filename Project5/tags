	session.vim	/^vmap  "-d$/;"	m
ÎÔ	session.vim	/^imap ÎÔ *$/;"	m
ÎÔ	session.vim	/^nmap ÎÔ "*P$/;"	m
ÎÔ	session.vim	/^vmap ÎÔ "-d"*P$/;"	m
ÎÕ	session.vim	/^vmap ÎÕ "*y$/;"	m
Î×	session.vim	/^vmap Î× "*d$/;"	m
ÎØ	session.vim	/^vmap ÎØ "*d$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
(	session.vim	/^inoremap <buffer> <silent> ( :call Open_bracket()$/;"	m
0	session.vim	/^normal! 0$/;"	m
02l	session.vim	/^normal! 02l$/;"	m
03l	session.vim	/^normal! 03l$/;"	m
057l	session.vim	/^normal! 057l$/;"	m
065l	session.vim	/^normal! 065l$/;"	m
06l	session.vim	/^normal! 06l$/;"	m
<C-End>	session.vim	/^map! <C-End> <C-End>$/;"	m
<C-End>	session.vim	/^nmap <C-End> <C-End>$/;"	m
<C-End>	session.vim	/^vmap <C-End> <C-End>$/;"	m
<C-Home>	session.vim	/^map! <C-Home> <C-Home>$/;"	m
<C-Home>	session.vim	/^nmap <C-Home> <C-Home>$/;"	m
<C-Home>	session.vim	/^vmap <C-Home> <C-Home>$/;"	m
<Plug>FireplaceSource	session.vim	/^nnoremap <Plug>FireplaceSource :Source $/;"	m
<Plug>NERDCommenterAlignBoth	session.vim	/^nnoremap <silent> <Plug>NERDCommenterAlignBoth :call NERDComment("n", "AlignBoth")$/;"	m
<Plug>NERDCommenterAlignLeft	session.vim	/^nnoremap <silent> <Plug>NERDCommenterAlignLeft :call NERDComment("n", "AlignLeft")$/;"	m
<Plug>NERDCommenterAppend	session.vim	/^nnoremap <silent> <Plug>NERDCommenterAppend :call NERDComment("n", "Append")$/;"	m
<Plug>NERDCommenterComment	session.vim	/^nnoremap <silent> <Plug>NERDCommenterComment :call NERDComment("n", "Comment")$/;"	m
<Plug>NERDCommenterInsert	session.vim	/^inoremap <silent> <Plug>NERDCommenterInsert  <BS>:call NERDComment('i', "insert")$/;"	m
<Plug>NERDCommenterInvert	session.vim	/^nnoremap <silent> <Plug>NERDCommenterInvert :call NERDComment("n", "Invert")$/;"	m
<Plug>NERDCommenterMinimal	session.vim	/^nnoremap <silent> <Plug>NERDCommenterMinimal :call NERDComment("n", "Minimal")$/;"	m
<Plug>NERDCommenterNested	session.vim	/^nnoremap <silent> <Plug>NERDCommenterNested :call NERDComment("n", "Nested")$/;"	m
<Plug>NERDCommenterSexy	session.vim	/^nnoremap <silent> <Plug>NERDCommenterSexy :call NERDComment("n", "Sexy")$/;"	m
<Plug>NERDCommenterToEOL	session.vim	/^nnoremap <silent> <Plug>NERDCommenterToEOL :call NERDComment("n", "ToEOL")$/;"	m
<Plug>NERDCommenterToggle	session.vim	/^nnoremap <silent> <Plug>NERDCommenterToggle :call NERDComment("n", "Toggle")$/;"	m
<Plug>NERDCommenterUncomment	session.vim	/^nnoremap <silent> <Plug>NERDCommenterUncomment :call NERDComment("n", "Uncomment")$/;"	m
<Plug>NERDCommenterYank	session.vim	/^nnoremap <silent> <Plug>NERDCommenterYank :call NERDComment("n", "Yank")$/;"	m
<Plug>NetrwBrowseX	session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
AckMessage	Common.h	/^} AckMessage;$/;"	t	typeref:struct:__anon1
COMMON_H	Common.h	4;"	d
CreateServerSocket	MyNetworking.c	/^int CreateServerSocket(int listenPort)$/;"	f
MAX_CONNECTIONS	MyNetworking.h	13;"	d
MAX_LEN	MyNetworking.h	12;"	d
MAX_MESSAGE_LENGTH	MyNetworking.h	14;"	d
MAX_SEGMENT_SIZE	MyNetworking.h	17;"	d
MYNETWORKING_H	MyNetworking.h	10;"	d
RoutingTable	dijkstra.h	/^} RoutingTable;$/;"	t	typeref:struct:__anon3
SegmentMessage	Common.h	/^} SegmentMessage;$/;"	t	typeref:struct:__anon2
SendParams	MyNetworking.h	/^}SendParams;$/;"	t	typeref:struct:__anon4
SessionLoad	session.vim	/^let SessionLoad = 1$/;"	v
TIMEOUT_VAL	MyNetworking.h	15;"	d
\		session.vim	/^map \\	 :tabn$/;"	m
\c	session.vim	/^nmap \\c  <Plug>NERDCommenterToggle$/;"	m
\c$	session.vim	/^nmap \\c$ <Plug>NERDCommenterToEOL$/;"	m
\cA	session.vim	/^nmap \\cA <Plug>NERDCommenterAppend$/;"	m
\ca	session.vim	/^nmap \\ca <Plug>NERDCommenterAltDelims$/;"	m
\cb	session.vim	/^nmap \\cb <Plug>NERDCommenterAlignBoth$/;"	m
\cc	session.vim	/^nmap \\cc <Plug>NERDCommenterComment$/;"	m
\ci	session.vim	/^nmap \\ci <Plug>NERDCommenterInvert$/;"	m
\cl	session.vim	/^nmap \\cl <Plug>NERDCommenterAlignLeft$/;"	m
\cm	session.vim	/^nmap \\cm <Plug>NERDCommenterMinimal$/;"	m
\cn	session.vim	/^nmap \\cn <Plug>NERDCommenterNested$/;"	m
\cs	session.vim	/^nmap \\cs <Plug>NERDCommenterSexy$/;"	m
\cu	session.vim	/^nmap \\cu <Plug>NERDCommenterUncomment$/;"	m
\cy	session.vim	/^nmap \\cy <Plug>NERDCommenterYank$/;"	m
\e	session.vim	/^map \\e gg=G$/;"	m
\m	session.vim	/^map \\m :call MakeSession()$/;"	m
\rce	session.vim	/^map \\rce :tabnew $myvimrc$/;"	m
\rcr	session.vim	/^map \\rcr :so $myvimrc$/;"	m
\t	session.vim	/^map \\t :TlistToggle$/;"	m
addresses	dijkstra.h	/^	struct sockaddr_in **addresses;$/;"	m	struct:__anon3	typeref:struct:__anon3::sockaddr_in
bool	MyNetworking.h	18;"	d
compareAddresses	MyNetworking.c	/^bool compareAddresses(struct sockaddr_in *a, struct sockaddr_in *b)$/;"	f
contactHost	Common.c	/^int contactHost(int socket, struct sockaddr_in *hostAddress)$/;"	f
createAndLoadRoutingTable	dijkstra.c	/^RoutingTable* createAndLoadRoutingTable(int numNodes, char currentNodeLabel, char *pathToNetworkFile)$/;"	f
createServerSocket	MyNetworking.c	/^int createServerSocket(struct sockaddr_in*  serverAddress)$/;"	f
data	Common.h	/^	char *data;$/;"	m	struct:__anon2
data	MyNetworking.h	/^	char *data;$/;"	m	struct:__anon4
decodeAckMessage	Common.c	/^void decodeAckMessage(char *message, AckMessage *ack)$/;"	f
decodeSegmentMessage	Common.c	/^void decodeSegmentMessage(char *message, SegmentMessage *segment)$/;"	f
delay	MyNetworking.h	/^	int delay;$/;"	m	struct:__anon4
exitError	MyNetworking.c	/^void exitError(char *error)$/;"	f
false	MyNetworking.h	20;"	d
freeRoutingTable	dijkstra.c	/^void freeRoutingTable(RoutingTable *table)$/;"	f
gD	session.vim	/^map gD <press Ctrl-]>$/;"	m
gd	session.vim	/^nmap gd <press Ctrl-]>$/;"	m
getAddress	MyNetworking.c	/^in_addr_t getAddress(char *hostname)$/;"	f
getEchoReply	MyNetworking.c	/^char *getEchoReply(char *message)$/;"	f
getErrorReply	MyNetworking.c	/^char *getErrorReply()$/;"	f
getIPAddressString	MyNetworking.c	/^char *getIPAddressString(struct sockaddr_in *address, char *buffer)$/;"	f
getLoadAvgReply	MyNetworking.c	/^char *getLoadAvgReply()$/;"	f
getPortFromAddress	MyNetworking.c	/^int getPortFromAddress(struct sockaddr_in *address)$/;"	f
getServerAddressStruct	MyNetworking.c	/^struct sockaddr_in *getServerAddressStruct(in_addr_t serverIP, int port)$/;"	f
getServerHostName	MyNetworking.c	/^char *getServerHostName()$/;"	f
getSocketAddress	MyNetworking.c	/^struct sockaddr_in *getSocketAddress(int socket)$/;"	f
getSocketPort	MyNetworking.c	/^int getSocketPort(int socket)$/;"	f
getTablePrintString	dijkstra.c	/^void getTablePrintString(RoutingTable *table, char *buffer)$/;"	f
getTablePrintStringWithAddresses	dijkstra.c	/^void getTablePrintStringWithAddresses(RoutingTable *table, char *buffer)$/;"	f
gx	session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
homeNode	dijkstra.h	/^	char homeNode;$/;"	m	struct:__anon3
isCorrupt	Common.h	/^	bool isCorrupt;$/;"	m	struct:__anon1
isCorrupt	Common.h	/^	bool isCorrupt;$/;"	m	struct:__anon2
labels	dijkstra.h	/^	char *labels;$/;"	m	struct:__anon3
lengths	dijkstra.h	/^	int *lengths;$/;"	m	struct:__anon3
loadTableFromFile	dijkstra.c	/^void loadTableFromFile(RoutingTable *table, FILE *fp)$/;"	f
main	dijkstraTester.c	/^int main(int argc, char **argv)$/;"	f
newRoutingTable	dijkstra.c	/^RoutingTable* newRoutingTable(int numNodes, char homeNode)$/;"	f
numNodes	dijkstra.h	/^	int numNodes;$/;"	m	struct:__anon3
ports	dijkstra.h	/^	short *ports;$/;"	m	struct:__anon3
predecessors	dijkstra.h	/^	char *predecessors;$/;"	m	struct:__anon3
printAddressStats	MyNetworking.c	/^void printAddressStats(struct sockaddr_in *address)$/;"	f
printIPAddress	MyNetworking.c	/^void printIPAddress(char* message, struct sockaddr_in *clientAddress)$/;"	f
printSocketStats	MyNetworking.c	/^void printSocketStats(int socket)$/;"	f
recvPacket	MyNetworking.c	/^int recvPacket(int socket, struct sockaddr_in *senderAddress, char *buffer)$/;"	f
s:cpo_save	session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	session.vim	/^let s:l = 1 - ((0 * winheight(0) + 12) \/ 25)$/;"	v
s:l	session.vim	/^let s:l = 1 - ((0 * winheight(0) + 42) \/ 84)$/;"	v
s:l	session.vim	/^let s:l = 12 - ((11 * winheight(0) + 42) \/ 84)$/;"	v
s:l	session.vim	/^let s:l = 135 - ((134 * winheight(0) + 28) \/ 57)$/;"	v
s:l	session.vim	/^let s:l = 15 - ((14 * winheight(0) + 42) \/ 84)$/;"	v
s:l	session.vim	/^let s:l = 21 - ((20 * winheight(0) + 42) \/ 84)$/;"	v
s:l	session.vim	/^let s:l = 278 - ((77 * winheight(0) + 28) \/ 57)$/;"	v
s:l	session.vim	/^let s:l = 3 - ((2 * winheight(0) + 28) \/ 57)$/;"	v
s:l	session.vim	/^let s:l = 3 - ((2 * winheight(0) + 42) \/ 84)$/;"	v
s:l	session.vim	/^let s:l = 59 - ((28 * winheight(0) + 12) \/ 25)$/;"	v
s:so_save	session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
sendUDPPacket	MyNetworking.c	/^int sendUDPPacket(int socket, struct sockaddr_in *address, char *data)$/;"	f
seqNum	Common.h	/^	int seqNum;$/;"	m	struct:__anon1
seqNum	Common.h	/^	int seqNum;$/;"	m	struct:__anon2
setUpSocket	MyNetworking.c	/^int setUpSocket()$/;"	f
socket	MyNetworking.h	/^	int socket;$/;"	m	struct:__anon4
toAddress	MyNetworking.h	/^	struct sockaddr_in *toAddress;$/;"	m	struct:__anon4	typeref:struct:__anon4::sockaddr_in
true	MyNetworking.h	19;"	d
updateRoutingTable	dijkstra.c	/^void updateRoutingTable(RoutingTable *table, char fromNode, int *lengths)$/;"	f
zc	session.vim	/^normal zc$/;"	m
zo	session.vim	/^normal zo$/;"	m
zt	session.vim	/^normal! zt$/;"	m
